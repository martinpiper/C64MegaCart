* Currently there is one 8-bit latch for the whole bank register, in IO1
	At power on, after _RESET, _GAME is high and _EXROM is low, giving 8KB ROML based cartridge
	Adding another register in IO2 will allow the _GAME and _EXROM lines to be controlled
	* It would be possible to set _GAME low and have _EXROM high (from IO2 register) only when A15 is set and R_W is low and when RGAME (IO2 register control GAME bit) is high and PHI2 is high
		This would give ultimax mode and allow writes to $e000-$ffff to control the address (plus IO1 bank register) and data lines lines to the flash _WE (_RWE i.e. ROM _WE) signal
		_ROMH would go straight to _RWE
	* Using M29F160FT55N3E2
	Page 25 Command write signals
		>> Note _OE must be high during commands/programming
		>> The address inputs are latched by the command interface on the falling edge of CE# or WE#, whichever occurs last.
		>> The data I/Os are latched by the command interface on the rising edge of CE# or WE#, whichever occurs first.
	Page 31 programm command, chip erase, block erase etc
	Page 37 https://www.mouser.sg/datasheet/2/12/M29FxxFT_FB-2999423.pdf says "Bus Read operations from any address always read the Status Register during Program and Erase operations."
	Page 47 Documents VID voltage 11.5V-12.5V
	Page 53 Gives program and erase timings, in seconds!
		Chip erase typical 25 seconds, max 120 seconds!!
		Block erase typcial 0.8 seconds, max 6 seconds!!
	>> Note: During Program operations the Data Polling Bit outputs the complement of the bit being programmed to DQ7. After successful completion of the Program operation the
memory returns to Read mode and Bus Read operations from the address just programmed output DQ7, not its complement.





* Option to have _GAME and _EXROM dynamically low only for CPU read access, giving VIC the RAM under the cartridge
	And only _GAME for $e000 option, giving ROM replacement as an option
	
	
	
* C64 flash write option (_RWE), with writes to $e000-$ffff activing as flash write when in ultimax mode
	Retain the pad/hole with _RWE and RYBY, it might be useful for the external programmer...




* Real cartridge data:
	Ensure Scroller multidirection code is built in gmod2 mode
	C:\Users\marti\Downloads\SDLVICE-3.7.1-win64-r43772\SDLVICE-3.7.1-win64-r43772\cartconv.exe -f c:\work\c64\Scroller\Scroller.crt
	C:\Users\marti\Downloads\SDLVICE-3.7.1-win64-r43772\SDLVICE-3.7.1-win64-r43772\cartconv.exe -i c:\work\c64\Scroller\Scroller.crt -o c:\temp\scrollerbanks.bin




* CartTool V2: Level convertors can be replaced with on-board circuitry
	Part BSS138
		https://www.mouser.sg/ProductDetail/SparkFun/BOB-12009?qs=WyAARYrbSnb%252BGYLWggQnjQ%3D%3D
		https://www.mouser.sg/datasheet/2/813/BSS138-1095242.pdf
		https://learn.sparkfun.com/tutorials/bi-directional-logic-level-converter-hookup-guide/all
		https://www.sparkfun.com/sparkfun-logic-level-converter-bi-directional.html
		Schematic: https://cdn.sparkfun.com/datasheets/BreakoutBoards/Logic_Level_Bidirectional.pdf
		Part: CR0805-JW-103ELF :  https://www.mouser.sg/ProductDetail/Bourns/CR0805-JW-103ELF?qs=3T0Ne7aOLxCPz7FUKqmeVw%3D%3D
	>> Or maybe this IC based 8 channel option: https://www.mouser.sg/ProductDetail/Adafruit/395?qs=GURawfaeGuC1aDMKJdj9pQ%3D%3D
		https://www.adafruit.com/product/395?srsltid=AfmBOop50Xub3xZMxZeb-DouSMTEdDp58jleg9IizkwYl-zjWiWnu4h0
		Schematic https://github.com/adafruit/Adafruit-TXB0108-PCB
		But it does not have strong output for LEDs etc




* CartTool V2: Perhaps have the _IO/_ROM outputs (faked from the C64) default to 1 on powerup?




* MegaCart V2.0
	* Board edge for cart case, maybe a bit wider after the edge connector
	* Done : Central mounting hole, for cart case
		References: https://github.com/bwack/C64-cartridge-template-kicad5
		https://wiki.icomp.de/w/images/d/de/Cart_case_bottom.png
		https://wiki.icomp.de/wiki/C64_Cartridge_Cases
	* Done: Chamfer card edge
	* Done: _EXROM disable logic
		* Software enable/disable _EXROM write $80 to $dfxx
			Defaults to $00 (enabling _EXROM = 0)
	* Done: Flash write logic
		* Flash write sequence:
			Run code in RAM at 0-$fff
			Write 8K bank using $dexx
			$dfxx = $40 : _EXROM=0 and REQFLASH=1
			Write erase chip/bank command bytes to $e000-$ffff
			Read status from $8000-$9fff, until $ff, repeat if needed
			Write program command bytes to $e000-$ffff
			Write final data to $e000-$ffff range
			Read back correct final data from $8000-$9fff, retry if needed
	>> While V1.0 had a separate pad for _RWE to allow fast programming (flash write), the C64 had no access to the signal via the expansion port, V2.0 has programming (flash write) coming from _ROMH directly.
		This means the C64 can assert _ROMH (via the REQFLASH mechanism which leads to _GAME), or the fast programmer can assert _ROMH directly without needing to set REQFLASH.
	> CartTool works
	> C64 cart bank works, as well as the kill control
	> C64 flash write also works, under two seconds to write 8KB of erased flash.
	* Use proper kernal address :)
	>> Block erase works. The BOM uses a M29F160FT55N3E2, which is (according to page 8 of the datasheet) is a "top boot block" version, which has a 8KB block at $1fa000
		This equates to setting bank $fd before issuign the block erase.




* Edge conector should not have any power plane near the pads.
