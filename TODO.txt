* Currently there is one 8-bit latch for the whole bank register, in IO1
	At power on, after _RESET, _GAME is high and _EXROM is low, giving 8KB ROML based cartridge
	Adding another register in IO2 will allow the _GAME and _EXROM lines to be controlled
	* It would be possible to set _GAME low and have _EXROM high (from IO2 register) only when A15 is set and R_W is low and when RGAME (IO2 register control GAME bit) is high and PHI2 is high
		This would give ultimax mode and allow writes to $e000-$ffff to control the address (plus IO1 bank register) and data lines lines to the flash _WE (_RWE i.e. ROM _WE) signal
		_ROMH would go straight to _RWE
	* Using M29F160FT55N3E2
	Page 25 Command write signals
		>> Note _OE must be high during commands/programming
		>> The address inputs are latched by the command interface on the falling edge of CE# or WE#, whichever occurs last.
		>> The data I/Os are latched by the command interface on the rising edge of CE# or WE#, whichever occurs first.
	Page 31 programm command, chip erase, block erase etc
	Page 37 https://www.mouser.sg/datasheet/2/12/M29FxxFT_FB-2999423.pdf says "Bus Read operations from any address always read the Status Register during Program and Erase operations."
	Page 47 Documents VID voltage 11.5V-12.5V
	Page 53 Gives program and erase timings, in seconds!
		Chip erase typical 25 seconds, max 120 seconds!!
		Block erase typcial 0.8 seconds, max 6 seconds!!
	>> Note: During Program operations the Data Polling Bit outputs the complement of the bit being programmed to DQ7. After successful completion of the Program operation the
memory returns to Read mode and Bus Read operations from the address just programmed output DQ7, not its complement.





* Option to have _GAME and _EXROM dynamically low only for CPU read access, giving VIC the RAM under the cartridge
	And only _GAME for $e000 option, giving ROM replacement as an option
	
	
	
* C64 flash write option (_RWE), with writes to $e000-$ffff activing as flash write when in ultimax mode
	Retain the pad/hole with _RWE and RYBY, it might be useful for the external programmer...




* Real cartridge data:
	Ensure Scroller multidirection code is built in gmod2 mode
	C:\Users\marti\Downloads\SDLVICE-3.7.1-win64-r43772\SDLVICE-3.7.1-win64-r43772\cartconv.exe -f c:\work\c64\Scroller\Scroller.crt
	C:\Users\marti\Downloads\SDLVICE-3.7.1-win64-r43772\SDLVICE-3.7.1-win64-r43772\cartconv.exe -i c:\work\c64\Scroller\Scroller.crt -o c:\temp\scrollerbanks.bin




* CartTool V2: Perhaps have the _IO/_ROM outputs (faked from the C64) default to 1 on powerup?




* Edge conector should not have any power plane near the pads.



* Maybe a Python flask based website?
	Which can call the relevant PiCartTool command line options?
	>> https://flask.palletsprojects.com/en/stable/installation/#python-version
