* Currently there is one 8-bit latch for the whole bank register, in IO1
	At power on, after _RESET, _GAME is high and _EXROM is low, giving 8KB ROML based cartridge
	Adding another register in IO2 will allow the _GAME and _EXROM lines to be controlled
	* It would be possible to set _GAME low and have _EXROM high (from IO2 register) only when A15 is set and R_W is low and when RGAME (IO2 register control GAME bit) is high and PHI2 is high
		This would give ultimax mode and allow writes to $e000-$ffff to control the address (plus IO1 bank register) and data lines lines to the flash _WE (_RWE i.e. ROM _WE) signal
		_ROMH would go straight to _RWE
	* Using M29F160FT55N3E2
	Page 25 Command write signals
		>> Note _OE must be high during commands/programming
		>> The address inputs are latched by the command interface on the falling edge of CE# or WE#, whichever occurs last.
		>> The data I/Os are latched by the command interface on the rising edge of CE# or WE#, whichever occurs first.
	Page 31 programm command, chip erase, block erase etc
	Page 37 https://www.mouser.sg/datasheet/2/12/M29FxxFT_FB-2999423.pdf says "Bus Read operations from any address always read the Status Register during Program and Erase operations."
	Page 47 Documents VID voltage 11.5V-12.5V
	Page 53 Gives program and erase timings, in seconds!
		Chip erase typical 25 seconds, max 120 seconds!!
		Block erase typcial 0.8 seconds, max 6 seconds!!
	>> Note: During Program operations the Data Polling Bit outputs the complement of the bit being programmed to DQ7. After successful completion of the Program operation the
memory returns to Read mode and Bus Read operations from the address just programmed output DQ7, not its complement.





* Option to have _GAME and _EXROM dynamically low only for CPU read access, giving VIC the RAM under the cartridge
	And only _GAME for $e000 option, giving ROM replacement as an option
	
	
	
* C64 flash write option (_RWE), with writes to $e000-$ffff activing as flash write when in ultimax mode
	Retain the pad/hole with _RWE and RYBY, it might be useful for the external programmer...




* Real cartridge data:
	Ensure Scroller multidirection code is built in gmod2 mode
	C:\Users\marti\Downloads\SDLVICE-3.7.1-win64-r43772\SDLVICE-3.7.1-win64-r43772\cartconv.exe -f c:\work\c64\Scroller\Scroller.crt
	C:\Users\marti\Downloads\SDLVICE-3.7.1-win64-r43772\SDLVICE-3.7.1-win64-r43772\cartconv.exe -i c:\work\c64\Scroller\Scroller.crt -o c:\temp\scrollerbanks.bin




* CartTool V2: Perhaps have the _IO/_ROM outputs (faked from the C64) default to 1 on powerup?




* Edge conector should not have any power plane near the pads.



* Maybe a Python flask based website?
	Which can call the relevant PiCartTool command line options?
	>> https://flask.palletsprojects.com/en/stable/installation/#python-version
	>> On Windows:
		pip install Flask
	>> On RaspberryPi5:
		cd ~/projects/PiCartTool
		python3 -m venv .venv
		. .venv/bin/activate
		pip install Flask
	>> Then: flask --app Programmer run --host=0.0.0.0
	>> http://127.0.0.1:5000
	>> http://raspberrypi5:5000/




* The middle hole might need to rest on the 6mm post with enough room to avoid the screw thread and with suitable gap between case top and bottom parts.



* Maybe a linear read byte mode, normally direct memory to low/high ROM uses the memory address and this should remain. However if reading a specific value in $dexx or $dfxx could return a linearly address byte this would help fast decompression or scrolling or video etc...
	Perhaps a bank of counters can be set by writing to specific $dexx/$dfxx, then each specific $dexx/dfxx read can advance that counter by one on the negative edge of _READ, giving enough time for a stable value to be read from the memory? Or even incremented on the _READ positive edge, assuming the read value can be held for long enough...
	It may also be possible to have more than one counter bank set and selected and advanced by a read from different IO space addresses... Giving multiple linear multiplexed reads...




* Vice driver
	https://master.dl.sourceforge.net/project/vice-emu/releases/vice-3.1.tar.gz?viasf=1
	D:\Work\Vice-3.1-with-C64MegaCart\vice-3.1\doc\building\Win32-MSVC-Howto.txt
		"D:\Work\Vice-3.1-with-C64MegaCart\vice-3.1\src\arch\win32\generate_msvc14_project.bat"
		"D:\Work\Vice-3.1-with-C64MegaCart\vice-3.1\src\arch\win32\vs14\vice.sln"
		x64sc startup project
			Build: DX Debug - Win32
			After failures, build again, not rebuild, just build (yes really)
	-cartc64megacart "C:\work\C64MegaCart\PiCartTool\scrollerbanks.bin"
	-autostartprgmode 1 -cartc64megacart "C:\temp\t.bin" -autostart "C:\work\C64MegaCart\FlashWriteTest.prg"
	TODO:
		* D:\Work\Vice-3.1-with-C64MegaCart\vice-3.1\src\c64\c64cart.h #define C64CART_ROM_LIMIT (2048 * 1024)
			>> Aftually C64MegaCart can be up to 128MB of Flash
		* Where is this enabled? FEATURE_CPUMEMHISTORY
			> D:\Work\Vice-3.1-with-C64MegaCart\vice-3.1\src\config.h.in
			D:\Work\Vice-3.1-with-C64MegaCart\vice-3.1\src\arch\win32\msvc\ide-config.h
				/* FIXME: Doesn't work with the rewrite. #define FEATURE_CPUMEMHISTORY 1*/
		* Note: /* FIXME: some models support non-uniform sector layout */
	> Build: https://github.com/martinpiper/Vice-3.1-with-C64MegaCart/tree/main/vice-3.1/data
