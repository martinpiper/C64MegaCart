; Assemble the source with: ..\c64\acme.exe -v9 -f cbm -o FlashWriteTest.prg --lib ..\c64\ "FlashWriteTest.a"
; Compress with: ..\C64\bin\LZMPi.exe -c64mbu FlashWriteTest.prg FlashWriteTest.prg $200
; Run with: "C:\Users\marti\Desktop\EF3\easytransfer-win32-1.2.0\easytransfer\ef3xfer.exe" -x FlashWriteTest.prg
; C64 build and run: ..\c64\acme.exe -v9 -f cbm -o FlashWriteTest.prg --lib ..\c64\ "FlashWriteTest.a" && ..\C64\bin\LZMPi.exe -c64mbu FlashWriteTest.prg FlashWriteTest.prg $200 && "C:\Users\marti\Desktop\EF3\easytransfer-win32-1.2.0\easytransfer\ef3xfer.exe" -x FlashWriteTest.prg
; Emu build and debug: ..\c64\acme.exe -v9 -f cbm -o FlashWriteTest.prg --lib ..\c64\ "FlashWriteTest.a" && ..\C64\bin\LZMPi.exe -c64mbu FlashWriteTest.prg FlashWriteTest.prg $200 && FlashWriteTest.prg

; MegaCart V2.0 - Flash write test, in ultimax mode. All IRQs/NMIs must be stopped and all code and data in the first 4K (0 - $1000).

; Fire = Advance test state

!initmem $20

!source "stdlib/stdlib.a"

CART_SELECT_BANK		= MemoryMappedIOArea1
CART_CONTROL			= MemoryMappedIOArea2
CART_CONTROL_FLASHWRITE	= $40
CART_CONTROL_CARTKILL	= $80

*=$0200
	lda #ProcessorPortDefault
	jsr InitialiseMachine

.l1
	; Init the cart to power on reset values, incase the reset signal was not passed through when the cart was plugged in and enabled with any switches in a cart expander
	+MByteValueToAddress_A 0 , CART_SELECT_BANK
	+MByteValueToAddress_A 0 , CART_CONTROL

	; Setup a visible screen with lower RAM based charset, for ultimax cartridges
	+MByteValueToAddress_A VIC2ScreenControlVDefault , VIC2ScreenControlV
	+MVIC2MemorySetup_ScreenChar_A SCREENRAM , Chars
	sta VIC2MemorySetup
	+MByteValueToAddress_A CIA2PortASerialBusVICBankDefault , CIA2PortASerialBusVICBank
	+MByteValueToAddress_A VIC2ScreenControlHDefault , VIC2ScreenControlH
	
	+DisplayTextAt_AX .thisIsRAM , .thisIsRAMEnd , C64Cartridge_Lo_8K

	; Check cart kill
.bt1
	jsr .eraseTopLine
	+DisplayTextAt_AX .pressFireForKillTest , .pressFireForKillTestEnd , SCREENRAM
	+WaitForFire_A
	jsr .eraseTopLine
	+DisplayTextAt_AX .isCartBank , .isCartBankEnd , SCREENRAM
	+MByteValueToAddress_A 0 , CART_SELECT_BANK
	+MByteValueToAddress_A 0 , CART_CONTROL
	jsr .displayBank
	+WaitForFire_A
	+DisplayTextAt_AX .isRAM , .isRAMEnd , SCREENRAM
	+MByteValueToAddress_A CART_CONTROL_CARTKILL , CART_CONTROL
	jsr .displayBank
;	jmp .bt1
	+WaitForFire_A
	+MByteValueToAddress_A 0 , CART_CONTROL
	jsr .displayBank

	; Erase cart
	jsr .eraseTopLine
	+DisplayTextAt_AX .pressFireToStartErase , .pressFireToStartEraseEnd , SCREENRAM
	+WaitForFire_A
	jsr .eraseTopLine
	+MByteValueToAddress_A CART_CONTROL_CARTKILL | CART_CONTROL_FLASHWRITE , CART_CONTROL
	+MByteValueToAddress_A $aa , C64Cartridge_Hi_8K + $aaa
	+MByteValueToAddress_A $55 , C64Cartridge_Hi_8K + $555
	+MByteValueToAddress_A $80 , C64Cartridge_Hi_8K + $aaa
	+MByteValueToAddress_A $aa , C64Cartridge_Hi_8K + $aaa
	+MByteValueToAddress_A $55 , C64Cartridge_Hi_8K + $555
	+MByteValueToAddress_A $10 , C64Cartridge_Hi_8K + $aaa

	+MByteValueToAddress_A 0 , CART_CONTROL
.l2
	+MACROWaitForTheLastScan_A	; There is no real need to wait for the raster, it's just to allow the status byte display to update on the screen.
	inc SCREENRAM+VIC2ScreenCharsWidth-1	 ; Running indicator

	; Check for $ff to be returned in the status byte, and display the status byte as a hex value
	lda C64Cartridge_Lo_8K
	sta SCREENRAM
	pha
	and #$0f
	tax
	lda .hexNumbers,x
	sta SCREENRAM + 4
	pla
	pha
	lsr
	lsr
	lsr
	lsr
	lda .hexNumbers,x
	sta SCREENRAM + 3
	pla
	cmp #$ff
	bne .l2
	
	; Erase done!
	jsr .eraseTopLine
	+DisplayTextAt_AX .eraseComplete , .eraseCompleteEnd , SCREENRAM
	+WaitForFire_A


	; Setup the 8KB write addresses
	+MByteValueToAddress_A >.flashTestData , .smra1+2
	+MByteValueToAddress_A >C64Cartridge_Hi_8K , .smwa1+2	; For ROMH

	; Write 8KB of data to the current bank
	ldx #0
.fw1
	lda #'*'
	sta SCREENRAM + VIC2ScreenCharsWidth,x

	+MByteValueToAddress_A CART_CONTROL_CARTKILL | CART_CONTROL_FLASHWRITE , CART_CONTROL
	+MByteValueToAddress_A $aa , C64Cartridge_Hi_8K + $aaa
	+MByteValueToAddress_A $55 , C64Cartridge_Hi_8K + $555
	+MByteValueToAddress_A $a0 , C64Cartridge_Hi_8K + $aaa
	
.smra1	lda .flashTestData,x
.smwa1	sta C64Cartridge_Hi_8K,x
	sta SCREENRAM+2 ; The intended write value to test for

	; Copy the write address to the read result address, with address change for ROML not ROMH
	lda .smwa1+1
	sta .smra2+1
	lda .smwa1+2
	and #$1f
	ora #>C64Cartridge_Lo_8K
	sta .smra2+2
	
	; Read result until the byte matches
	+MByteValueToAddress_A 0 , CART_CONTROL
.rl2
;	+MACROWaitForTheLastScan_A	; Writing bytes there is really no need to wait for the raster, although you could.
	inc SCREENRAM+VIC2ScreenCharsWidth-1	 ; Running indicator

.smra2	lda $8000,x
	sta SCREENRAM
	cmp SCREENRAM+2
	bne .rl2
	
	lda #$a0
	sta SCREENRAM + VIC2ScreenCharsWidth,x
	
	inx
	bne .fw1

	; And write the next pages with the test data
;	inc .smra1+2	; Don't update the reading page, we recycle the data. For real flash writing the read data high address will probably change.
	inc .smwa1+2
	bne .fw1

	jsr .displayBank

	jmp .l1

.eraseTopLine
	lda #' '
	ldx #VIC2ScreenCharsWidth-1
.cl1
	sta SCREENRAM,x
	dex
	bpl .cl1
	rts

; Displays the first bytes of each page in a cartridge 8K bank on each screen row, at screen row 2
.displayBank
	ldx #VIC2ScreenCharsWidth-1
.cp1
!for .i , 8 {
	lda C64Cartridge_Lo_8K + ((.i-1) * $100),x
	sta SCREENRAM + ((.i + 1) * VIC2ScreenCharsWidth),x
}
	dex
	bpl .cp1
	rts

+MCheckNotInMemoryRange SCREENRAM,$ffff

*=$0700
.flashTestData
	!scr "this is some test data..."

.pressFireForKillTest
	!scr "press fire to start kill test"
.pressFireForKillTestEnd

.pressFireToStartErase
	!scr "press fire to start erase command"
.pressFireToStartEraseEnd

.eraseComplete
	!scr "erase complete, press fire to write"
.eraseCompleteEnd

.thisIsRAM
	!scr "this is ram..."
.thisIsRAMEnd

.isCartBank
	!scr "cart bank, press fire"
.isCartBankEnd

.isRAM
	!scr "should be ram, press fire"
.isRAMEnd

.hexNumbers
	!scr "0123456789abcdef"


; Lowercase chars, for any ultimax mode carts
*=$800
Chars
!bin "C:\VICE\C64\chargen",,VIC2MemorySetup_CharsSize
	
; There is RAM here after running, but might not be when a cartridge is banked in	
Initialise_NoPreserveStack = 1
Initialise_NoMACROWaitForTheLastScan = 1
Initialise_NoIRQServiceRoutine = 1
!source "stdlib/Initialise.a"
